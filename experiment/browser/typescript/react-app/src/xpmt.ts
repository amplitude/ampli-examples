/* tslint:disable */
/* eslint-disable */
/**
 * Xpmt - A strong typed wrapper for your Experiment
 *
 * This file is generated by Amplitude.
 * To update run 'ampli exp -t token -d deployment-key'
 *
 * Required dependencies: @amplitude/experiment-js-client
 * Experiment Plan Version: 0
 * Build: 1.0.0
 * Runtime: browser:typescript
 */

import { Experiment, ExperimentClient, ExperimentConfig, ExperimentUser } from '@amplitude/experiment-js-client';

export type BaseExperiment = {
  key: string;
  name: string;
}

/* Codegen Array Experiment */
export namespace CodegenArrayExperimentVariants {
  export type Generic = { key: 'generic', payload: string[] };
  export type Ampli = { key: 'ampli', payload: string[] };

  export enum Keys {
    Generic = 'generic',
    Ampli = 'ampli'
  }
}
export type CodegenArrayExperimentType = BaseExperiment & {
  generic?: CodegenArrayExperimentVariants.Generic;
  ampli?: CodegenArrayExperimentVariants.Ampli;
}
export class CodegenArrayExperiment implements CodegenArrayExperimentType {
  key = 'codegen-array-experiment';
  name = "Codegen Array Experiment";
  variant: CodegenArrayExperimentVariants.Generic |CodegenArrayExperimentVariants.Ampli | undefined;

  constructor(
    public generic?: CodegenArrayExperimentVariants.Generic,
    public ampli?: CodegenArrayExperimentVariants.Ampli,
  ) {}
}
export namespace CodegenArrayExperiment {
  export const Key = 'codegen-array-experiment';
  export const Name = "Codegen Array Experiment";

  export enum Variants {
    Generic = 'generic',
    Ampli = 'ampli'
  }
}

/* Codegen Boolean Experiment */
export namespace CodegenBooleanExperimentVariants {
  export type On = { key: 'on', payload: boolean };

  export enum Keys {
    On = 'on'
  }
}
export type CodegenBooleanExperimentType = BaseExperiment & {
  on?: CodegenBooleanExperimentVariants.On;
}
export class CodegenBooleanExperiment implements CodegenBooleanExperimentType {
  key = 'codegen-boolean-experiment';
  name = "Codegen Boolean Experiment";
  variant: CodegenBooleanExperimentVariants.On | undefined;

  constructor(
    public on?: CodegenBooleanExperimentVariants.On,
  ) {}
}
export namespace CodegenBooleanExperiment {
  export const Key = 'codegen-boolean-experiment';
  export const Name = "Codegen Boolean Experiment";

  export enum Variants {
    On = 'on'
  }
}

/* Codegen String Experiment */
export namespace CodegenStringExperimentVariants {
  export type Control = { key: 'control', payload: string };
  export type Treatment = { key: 'treatment', payload: string };

  export enum Keys {
    Control = 'control',
    Treatment = 'treatment'
  }
}
export type CodegenStringExperimentType = BaseExperiment & {
  control?: CodegenStringExperimentVariants.Control;
  treatment?: CodegenStringExperimentVariants.Treatment;
}
export class CodegenStringExperiment implements CodegenStringExperimentType {
  key = 'codegen-string-experiment';
  name = "Codegen String Experiment";
  variant: CodegenStringExperimentVariants.Control |CodegenStringExperimentVariants.Treatment | undefined;

  constructor(
    public control?: CodegenStringExperimentVariants.Control,
    public treatment?: CodegenStringExperimentVariants.Treatment,
  ) {}
}
export namespace CodegenStringExperiment {
  export const Key = 'codegen-string-experiment';
  export const Name = "Codegen String Experiment";

  export enum Variants {
    Control = 'control',
    Treatment = 'treatment'
  }
}

/* Codegen Experiment */
export namespace CodegenExperimentVariants {
  export type Control = { key: 'control', payload: any };
  export type Treatment = { key: 'treatment', payload: any };

  export enum Keys {
    Control = 'control',
    Treatment = 'treatment'
  }
}
export type CodegenExperimentType = BaseExperiment & {
  control?: CodegenExperimentVariants.Control;
  treatment?: CodegenExperimentVariants.Treatment;
}
export class CodegenExperiment implements CodegenExperimentType {
  key = 'codegen-experiment';
  name = "Codegen Experiment";
  variant: CodegenExperimentVariants.Control |CodegenExperimentVariants.Treatment | undefined;

  constructor(
    public control?: CodegenExperimentVariants.Control,
    public treatment?: CodegenExperimentVariants.Treatment,
  ) {}
}
export namespace CodegenExperiment {
  export const Key = 'codegen-experiment';
  export const Name = "Codegen Experiment";

  export enum Variants {
    Control = 'control',
    Treatment = 'treatment'
  }
}

export class Xpmt {
  /**
   * Initialize experiment.
   *
   * @param apiKey Experiment deployment key.
   * @param config Experiment client configuration.
   */
  public static initialize(apiKey: string, config?: ExperimentConfig): Xpmt {
    const client = Experiment.initialize(apiKey, config);
    return new Xpmt(client);
  }

  /**
   * The underlying experiment client.
   */
  public readonly client: ExperimentClient;

  /**
   * Fetch variants for a user.
   *
   * This user is merged with the user provided by the client's user provider.
   *
   * @param user The user to fetch variants for.
   */
  public async fetch(user?: ExperimentUser): Promise<Xpmt> {
    await this.client.fetch(user)
    return this;
  }

  private constructor(client: ExperimentClient) {
    this.client = client;
  }

  private getTypedVariant<T extends BaseExperiment>(exp: T) {
    const variant = this.client.variant(exp.key);
    if (variant.value) {
      (exp as any)[variant.value] = { payload: variant.payload };
      (exp as any)['variant'] = { key: variant.value, payload: variant.payload };
    }

    return exp;
  }

  public codegenArrayExperiment(): CodegenArrayExperiment {
    return this.getTypedVariant(new CodegenArrayExperiment());
  }

  public codegenBooleanExperiment(): CodegenBooleanExperiment {
    return this.getTypedVariant(new CodegenBooleanExperiment());
  }

  public codegenStringExperiment(): CodegenStringExperiment {
    return this.getTypedVariant(new CodegenStringExperiment());
  }

  public codegenExperiment(): CodegenExperiment {
    return this.getTypedVariant(new CodegenExperiment());
  }

}
