// ampli.go
//
// Ampli - A strong typed wrapper for your Analytics
//
// This file is generated by Amplitude.
// To update run 'ampli pull go-ampli'
//
// Required dependencies: analytics-go
// Tracking Plan Version: 0
// Build: 1.0.0
// Runtime: go-ampli
//
// [View Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest
//
// [Full Setup Instructions]: https://data.amplitude.com/test-codegen/Test%20Codegen/implementation/main/latest/getting-started/go-ampli
//

package ampli

import (
	"log"
	"sync"

	"github.com/amplitude/analytics-go/amplitude"
)

var Instance = Ampli{}

type Environment string

const (
	EnvironmentDevelopment Environment = "development"
	EnvironmentProduction  Environment = "production"
)

var APIKey = map[Environment]string{
	EnvironmentDevelopment: "",
	EnvironmentProduction:  "",
}

func DefaultConfiguration() amplitude.Config {
	config := amplitude.NewConfig("")
	config.Plan = amplitude.Plan{
		Branch:    "main",
		Source:    "go-Ampli",
		Version:   "0",
		VersionID: "79154a50-f057-4db5-9755-775e4e9f05e6",
	}

	return config
}

// LoadClientOptions is Instance options setting to initialize Ampli client.
//
// Params:
// 	- APIKey: the API key of Amplitude project
// 	- Instance: the core SDK instance used by Ampli client
// 	- Configuration: the core SDK client configuration instance
type LoadClientOptions struct {
	APIKey        string
	Instance      amplitude.Client
	Configuration amplitude.Config
}

func (l LoadClientOptions) isEmpty() bool {
	return l.APIKey == "" && l.Instance == nil && l.Configuration.IsEmpty()
}

// LoadOptions is options setting to initialize Ampli client.
//
// Params:
//	- Environment: the environment of Amplitude Data project
//	- Disabled: the flag of disabled Ampli client
//	- Instance: the LoadClientOptions struct
type LoadOptions struct {
	Environment Environment
	Disabled    bool
	Client      LoadClientOptions
}

type baseEvent struct {
	eventType  string
	properties map[string]interface{}
}

type amplitudeEvent interface {
	toAmplitudeEvent() amplitude.Event
}

func newBaseEvent(eventType string, properties map[string]interface{}) *baseEvent {
	return &baseEvent{
		eventType:  eventType,
		properties: properties,
	}
}

func (event *baseEvent) toAmplitudeEvent() amplitude.Event {
	return amplitude.Event{
		EventType:       event.eventType,
		EventProperties: event.properties,
	}
}

// Identify
//
// [View in Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest/Identify
//
// Identify properties
//
// Params:
//	- RequiredNumber: description for Ampli.Identify RequiredNumber
//	- OptionalArray: description for Ampli.Identify OptionalArray
type Identify struct {
	*baseEvent
}

func NewIdentify(requiredNumber float64) *Identify {
	return &Identify{
		newBaseEvent(amplitude.IdentifyEventType, map[string]interface{}{
			"requiredNumber": requiredNumber,
		}),
	}
}

func (event *Identify) SetOptionalArray(optionalArray []string) *Identify {
	event.properties["optionalArray"] = optionalArray

	return event
}

func (event *Identify) toAmplitudeEvent() amplitude.Event {
	identify := amplitude.Identify{}

	for name, value := range event.properties {
		identify.Set(name, value)
	}

	return amplitude.Event{
		EventType:      event.eventType,
		UserProperties: identify.Properties,
	}
}

// Group
//
// [View in Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest/Group
//
// Group properties
//
// Params:
//	- RequiredBool: description for group RequiredBool
//	- OptionalString: description for group OptionalString
type Group struct {
	*baseEvent
	groups map[string][]string
}

func NewGroup(requiredBoolean bool) *Group {
	return &Group{
		baseEvent: newBaseEvent(amplitude.GroupIdentifyEventType, map[string]interface{}{
			"requiredBoolean": requiredBoolean,
		}),
	}
}

func (event *Group) SetOptionalString(optionString string) *Group {
	event.properties["optionalString"] = optionString

	return event
}

func (event *Group) toAmplitudeEvent() amplitude.Event {
	identify := amplitude.Identify{}
	for name, value := range event.properties {
		identify.Set(name, value)
	}

	return amplitude.Event{
		EventType:       event.eventType,
		GroupProperties: identify.Properties,
		Groups:          event.groups,
	}
}

// EventWithAllProperties
//
// [View in Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest/Event%20With%20Array%20Types
//
// Event with all properties
//
// Owner: Test codegen
//
// Params
//	- required_array: Event 2 Property - Array
//	- required_boolean: Event 2 Property - Boolean
//	- required_enum: Event 2 Property - Enum
//	- required_integer: Event 2 Property - Integer
//	- required_number: Event 2 Property - Number
//	- required_string: Event 2 Property - String
//	- optional_string: Event 2 Property - Optional String
type EventWithAllProperties struct {
	*baseEvent
}

type EventWithAllPropertiesRequiredEnum string

const (
	EventWithAllPropertiesRequiredEnumEnum1 EventWithAllPropertiesRequiredEnum = "Enum1"
	EventWithAllPropertiesRequiredEnumEnum2 EventWithAllPropertiesRequiredEnum = "Enum2"
)

func NewEventWithAllProperties(requiredArray []string, requiredBool bool, requiredEnum EventWithAllPropertiesRequiredEnum, requiredInteger int, requiredNumber float64, requiredString string) *EventWithAllProperties {
	return &EventWithAllProperties{
		newBaseEvent("Event With All Properties", map[string]interface{}{
			"requiredArray":   requiredArray,
			"requiredBool":    requiredBool,
			"requiredEnum":    requiredEnum,
			"requiredInteger": requiredInteger,
			"requiredNumber":  requiredNumber,
			"requiredString":  requiredString,
		}),
	}
}

func (event *EventWithAllProperties) SetOptionalString(optionalString string) *EventWithAllProperties {
	event.properties["optionalString"] = optionalString

	return event
}

func (event *EventWithAllProperties) SetOptionalBool(optionalBool bool) *EventWithAllProperties {
	event.properties["optionalBool"] = optionalBool

	return event
}

type Ampli struct {
	Disabled bool
	Client   amplitude.Client
	mutex    sync.RWMutex
}

// Load initializes the Ampli wrapper.
// Call once when your application starts.
func (a *Ampli) Load(options LoadOptions) {
	if a.Client != nil {
		log.Default().Printf("Warn: Ampli is already initialized. Ampli.load() should be called once at application start up.")

		return
	}

	if options.Client.isEmpty() {
		options.Client = LoadClientOptions{
			Configuration: DefaultConfiguration(),
		}
	}

	var apiKey string
	if options.Client.APIKey != "" {
		apiKey = options.Client.APIKey
	} else if options.Environment != "" {
		apiKey = APIKey[options.Environment]
	} else if options.Client.Configuration.APIKey != "" {
		apiKey = options.Client.Configuration.APIKey
	}

	if !(apiKey != "" || options.Client.Instance != nil) {
		log.Default().Printf("Error: Ampli.Load() requires option.Environment, " +
			"and apiKey from either options.Instance.APIKey or APIKey[options.Environment], " +
			"or options.Instance.Instance")
	}

	var configuration amplitude.Config
	if !options.Client.Configuration.IsEmpty() {
		configuration = options.Client.Configuration
	} else {
		configuration = DefaultConfiguration()
	}

	if configuration.Plan == (amplitude.Plan{}) {
		configuration.Plan = DefaultConfiguration().Plan
	}

	if options.Client.Instance != nil {
		a.Client = options.Client.Instance
	} else {
		configuration.APIKey = apiKey
		a.Client = amplitude.NewClient(configuration)
	}

	a.mutex.Lock()
	a.Disabled = options.Disabled
	a.mutex.Unlock()
}

// InitializedAndEnabled checks if Ampli is initialized and enabled.
func (a *Ampli) InitializedAndEnabled() bool {
	a.mutex.RLock()
	defer a.mutex.RUnlock()

	return !a.Disabled && a.Client != nil
}

func (a *Ampli) setUserID(userID string, eventOptions *amplitude.EventOptions) {
	if userID != "" {
		eventOptions.UserID = userID
	}
}

// Track tracks an amplitudeEvent.
func (a *Ampli) Track(userID string, event amplitudeEvent, eventOptions amplitude.EventOptions) {
	if !a.InitializedAndEnabled() {
		return
	}

	a.setUserID(userID, &eventOptions)

	baseEvent := event.toAmplitudeEvent()
	baseEvent.EventOptions = eventOptions

	a.Client.Track(baseEvent)
}

// Identify identifies a user and set user properties.
func (a *Ampli) Identify(userID string, identify *Identify, eventOptions amplitude.EventOptions) {
	a.Track(userID, identify, eventOptions)
}

// GroupIdentify identifies a group and set group properties.
func (a *Ampli) GroupIdentify(groupType string, groupName string, group *Group, eventOptions amplitude.EventOptions) {
	group.groups = map[string][]string{groupType: {groupName}}
	event := group.toAmplitudeEvent()
	event.EventOptions = eventOptions

	a.Client.Track(event)
}

// SetGroup sets group for the current user.
func (a *Ampli) SetGroup(userID string, groupType string, groupName []string, eventOptions amplitude.EventOptions) {
	a.setUserID(userID, &eventOptions)

	a.Client.SetGroup(groupType, groupName, eventOptions)
}

// Flush flushes events waiting in buffer.
func (a *Ampli) Flush() {
	if !a.InitializedAndEnabled() {
		return
	}

	a.Client.Flush()
}

// Shutdown disables and shutdowns Ampli Instance.
func (a *Ampli) Shutdown() {
	if !a.InitializedAndEnabled() {
		return
	}

	a.mutex.Lock()
	a.Disabled = true
	a.mutex.Unlock()

	a.Client.Shutdown()
}

func (a *Ampli) EventWithAllProperties(userID string, event *EventWithAllProperties, eventOptions amplitude.EventOptions) {
	a.Track(userID, event, eventOptions)
}
