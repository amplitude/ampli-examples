// ampli.go
//
// Ampli - A strong typed wrapper for your Analytics
//
// This file is generated by Amplitude.
// To update run 'ampli pull go-ampli'
//
// Required dependencies: analytics-go
// Tracking Plan Version: 0
// Build: 1.0.0
// Runtime: go-ampli
//
// [View Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest
//
// [Full Setup Instructions]: https://data.amplitude.com/test-codegen/Test%20Codegen/implementation/main/latest/getting-started/go-ampli
//

package ampli

import (
	"log"
	"sync"

	"github.com/amplitude/analytics-go/amplitude"
)

var Instance = Ampli{}

type Environment string

const (
	EnvironmentDevelopment Environment = "development"
	EnvironmentProduction  Environment = "production"
)

var APIKey = map[Environment]string{
	EnvironmentDevelopment: "",
	EnvironmentProduction:  "",
}

func DefaultConfiguration() amplitude.Config {
	config := amplitude.NewConfig("")
	config.Plan = amplitude.Plan{
		Branch:    "main",
		Source:    "go-Ampli",
		Version:   "0",
		VersionID: "79154a50-f057-4db5-9755-775e4e9f05e6",
	}

	return config
}

// LoadClientOptions is Instance options setting to initialize Ampli client.
//
// Params:
// 	- APIKey: the API key of Amplitude project
// 	- Instance: the core SDK instance used by Ampli client
// 	- Configuration: the core SDK client configuration instance
type LoadClientOptions struct {
	APIKey        string
	Instance      amplitude.Client
	Configuration amplitude.Config
}

func (l LoadClientOptions) isEmpty() bool {
	return l.APIKey == "" && l.Instance == nil && l.Configuration.IsEmpty()
}

// LoadOptions is options setting to initialize Ampli client.
//
// Params:
//	- Environment: the environment of Amplitude Data project
//	- Disabled: the flag of disabled Ampli client
//	- Instance: the LoadClientOptions struct
type LoadOptions struct {
	Environment Environment
	Disabled    bool
	Client      LoadClientOptions
}

type StronglyTypedEvent interface {
	ToEvent() amplitude.Event
}

// Identify
//
// [View in Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest/Identify
//
// Identify properties
//
// Params:
//	- RequiredNumber: description for Ampli.Identify RequiredNumber
//	- OptionalArray: description for Ampli.Identify OptionalArray
type Identify struct {
	RequiredNumber float64
	OptionalArray  []string
	optionals      map[string]bool
}

func NewIdentify(requiredNumber float64) *Identify {
	return &Identify{
		RequiredNumber: requiredNumber,
		optionals:      map[string]bool{},
	}
}

func (stronglyTypedEvent *Identify) SetOptionalArray(optionalArray []string) *Identify {
	stronglyTypedEvent.OptionalArray = optionalArray
	stronglyTypedEvent.optionals["OptionalArray"] = true

	return stronglyTypedEvent
}

func (stronglyTypedEvent *Identify) ToEvent() amplitude.Event {
	identify := amplitude.Identify{}
	identify.Set("requiredNumber", stronglyTypedEvent.RequiredNumber)

	if _, present := stronglyTypedEvent.optionals["OptionalArray"]; present {
		identify.Set("optionalArray", stronglyTypedEvent.OptionalArray)
	}

	return amplitude.Event{
		EventType:      amplitude.IdentifyEventType,
		UserProperties: identify.Properties,
	}
}

// Group
//
// [View in Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest/Group
//
// Group properties
//
// Params:
//	- RequiredBool: description for group RequiredBool
//	- OptionalString: description for group OptionalString
type Group struct {
	RequiredBoolean bool
	OptionalString  string
	groups          map[string][]string
	optionals       map[string]bool
}

func NewGroup(requiredBoolean bool) *Group {
	return &Group{
		RequiredBoolean: requiredBoolean,
		optionals:       map[string]bool{},
	}
}

func (stronglyTypedEvent *Group) SetOptionalString(optionString string) *Group {
	stronglyTypedEvent.OptionalString = optionString
	stronglyTypedEvent.optionals["OptionalString"] = true

	return stronglyTypedEvent
}

func (stronglyTypedEvent *Group) ToEvent() amplitude.Event {
	identify := amplitude.Identify{}
	identify.Set("requiredBoolean", stronglyTypedEvent.RequiredBoolean)

	if _, present := stronglyTypedEvent.optionals["OptionalArray"]; present {
		identify.Set("optionalString", stronglyTypedEvent.OptionalString)
	}

	return amplitude.Event{
		EventType:       amplitude.GroupIdentifyEventType,
		Groups:          stronglyTypedEvent.groups,
		GroupProperties: identify.Properties,
	}
}

// EventWithAllProperties
//
// [View in Tracking Plan]: https://data.amplitude.com/test-codegen/Test%20Codegen/events/main/latest/Event%20With%20Array%20Types
//
// Event with all properties
//
// Owner: Test codegen
//
// Params
//	- required_array: Event 2 Property - Array
//	- required_boolean: Event 2 Property - Boolean
//	- required_enum: Event 2 Property - Enum
//	- required_integer: Event 2 Property - Integer
//	- required_number: Event 2 Property - Number
//	- required_string: Event 2 Property - String
//	- optional_string: Event 2 Property - Optional String
type EventWithAllProperties struct {
	RequiredArray   []string
	RequiredBool    bool
	RequiredEnum    RequiredEnum
	RequiredInteger int
	RequiredNumber  float64
	RequiredString  string
	OptionalString  string
	OptionalBool    bool
	optionals       map[string]bool
}

type RequiredEnum string

const (
	RequiredEnumEnum1 RequiredEnum = "Enum1"
	RequiredEnumEnum2 RequiredEnum = "Enum2"
)

func NewEventWithAllProperties(requiredArray []string, requiredBool bool, requiredEnum RequiredEnum, requiredInteger int, requiredNumber float64, requiredString string) *EventWithAllProperties {
	return &EventWithAllProperties{
		RequiredArray:   requiredArray,
		RequiredBool:    requiredBool,
		RequiredEnum:    requiredEnum,
		RequiredInteger: requiredInteger,
		RequiredNumber:  requiredNumber,
		RequiredString:  requiredString,
		optionals:       map[string]bool{},
	}
}

func (stronglyTypedEvent *EventWithAllProperties) SetOptionalString(optionalString string) *EventWithAllProperties {
	stronglyTypedEvent.OptionalString = optionalString
	stronglyTypedEvent.optionals["OptionalString"] = true

	return stronglyTypedEvent
}

func (stronglyTypedEvent *EventWithAllProperties) SetOptionalBool(optionalBool bool) *EventWithAllProperties {
	stronglyTypedEvent.OptionalBool = optionalBool
	stronglyTypedEvent.optionals["OptionalBool"] = true

	return stronglyTypedEvent
}

func (stronglyTypedEvent EventWithAllProperties) ToEvent() amplitude.Event {
	event := amplitude.Event{
		EventType: "Event With All Properties",
		EventProperties: map[string]interface{}{
			"requiredArray":   stronglyTypedEvent.RequiredArray,
			"requiredBool":    stronglyTypedEvent.RequiredBool,
			"requiredEnum":    stronglyTypedEvent.RequiredEnum,
			"requiredInteger": stronglyTypedEvent.RequiredInteger,
			"requiredNumber":  stronglyTypedEvent.RequiredNumber,
			"requiredString":  stronglyTypedEvent.RequiredString,
		},
	}

	if _, present := stronglyTypedEvent.optionals["OptionalString"]; present {
		event.EventProperties["optionalString"] = stronglyTypedEvent.OptionalString
	}

	if _, present := stronglyTypedEvent.optionals["OptionalBool"]; present {
		event.EventProperties["optionalBool"] = stronglyTypedEvent.OptionalBool
	}

	return event
}

type Ampli struct {
	Disabled bool
	Client   amplitude.Client
	mutex    sync.Mutex
}

// Load initializes the Ampli wrapper.
// Call once when your application starts.
func (a *Ampli) Load(options LoadOptions) {
	a.mutex.Lock()
	a.Disabled = options.Disabled
	a.mutex.Unlock()

	if a.Client != nil {
		log.Default().Printf("Warn: Ampli is already initialized. Ampli.load() should be called once at application start up.")

		return
	}

	if options.Client.isEmpty() {
		options.Client = LoadClientOptions{
			Configuration: DefaultConfiguration(),
		}
	}

	var apiKey string
	if options.Client.APIKey != "" {
		apiKey = options.Client.APIKey
	} else if options.Environment != "" {
		apiKey = APIKey[options.Environment]
	} else if options.Client.Configuration.APIKey != "" {
		apiKey = options.Client.Configuration.APIKey
	}

	if !(apiKey != "" || options.Client.Instance != nil) {
		log.Default().Printf("Error: Ampli.Load() requires option.Environment, " +
			"and apiKey from either options.Instance.APIKey or APIKey[options.Environment], " +
			"or options.Instance.Instance")
	}

	var configuration amplitude.Config
	if !options.Client.Configuration.IsEmpty() {
		configuration = options.Client.Configuration
	} else {
		configuration = DefaultConfiguration()
	}

	if configuration.Plan == (amplitude.Plan{}) {
		configuration.Plan = DefaultConfiguration().Plan
	}

	if options.Client.Instance != nil {
		a.Client = options.Client.Instance
	} else {
		configuration.APIKey = apiKey
		a.Client = amplitude.NewClient(configuration)
	}
}

// InitializedAndEnabled checks if Ampli is initialized and enabled.
func (a *Ampli) InitializedAndEnabled() bool {
	a.mutex.Lock()
	defer a.mutex.Unlock()
	return !a.Disabled && a.Client != nil
}

func (a *Ampli) setUserID(userID string, eventOptions *amplitude.EventOptions) {
	if userID != "" {
		eventOptions.UserID = userID
	}
}

// Track tracks an StronglyTypedEvent.
func (a *Ampli) Track(userID string, event StronglyTypedEvent, eventOptions amplitude.EventOptions) {
	if !a.InitializedAndEnabled() {
		return
	}

	a.setUserID(userID, &eventOptions)

	baseEvent := event.ToEvent()
	baseEvent.EventOptions = eventOptions

	a.Client.Track(baseEvent)
}

// Identify identifies a user and set user properties.
func (a *Ampli) Identify(userID string, identify *Identify, eventOptions amplitude.EventOptions) {
	a.Track(userID, identify, eventOptions)
}

// GroupIdentify identifies a group and set group properties.
func (a *Ampli) GroupIdentify(groupType string, groupName string, group *Group, eventOptions amplitude.EventOptions) {
	group.groups = map[string][]string{groupType: {groupName}}
	event := group.ToEvent()
	event.EventOptions = eventOptions

	a.Client.Track(event)
}

// SetGroup sets group for the current user.
func (a *Ampli) SetGroup(userID string, groupType string, groupName []string, eventOptions amplitude.EventOptions) {
	a.setUserID(userID, &eventOptions)

	a.Client.SetGroup(groupType, groupName, eventOptions)
}

// Flush flushes events waiting in buffer.
func (a *Ampli) Flush() {
	if !a.InitializedAndEnabled() {
		return
	}

	a.Client.Flush()
}

// Shutdown disables and shutdowns Ampli Instance.
func (a *Ampli) Shutdown() {
	if !a.InitializedAndEnabled() {
		return
	}

	a.Client.Shutdown()
	a.mutex.Lock()
	a.Disabled = true
	a.mutex.Unlock()
}

func (a *Ampli) EventWithAllProperties(userID string, event *EventWithAllProperties, eventOptions amplitude.EventOptions) {
	a.Track(userID, event, eventOptions)
}
